// File: src/utils/googleDocsFormatter.js

const { Converter } = require('showdown'); // Requires showdown to be installed
const logger = require('./logger');

/**
 * Format Markdown content into Google Docs API requests
 * @param {string} markdown - Markdown content
 * @returns {Object} Google Docs API requests
 */
function formatMarkdownToGoogleDocsRequests(markdown) {
  try {
    logger.info('Converting markdown to Google Docs format via googleDocsFormatter');
    
    // Step 1: Initialize showdown converter (though its HTML output is not directly used for request generation below)
    const converter = new Converter({
      tables: true,
      tasklists: true,
      strikethrough: true,
      simpleLineBreaks: true
    });
    // To use showdown's HTML: const html = converter.makeHtml(markdown);
    // Then, you would need a new function to parse this HTML into Google Docs requests.
    
    // Step 2: Convert to Google Docs API requests using the manual markdown parser
    // This `convertToDocRequests` function parses the original markdown string directly.
    const { requests, index } = convertToDocRequests(markdown); 
    
    logger.info(`Successfully converted markdown to ${requests.length} Google Docs requests (using manual parsing for request structure)`);
    
    return { requests };
  } catch (error) {
    logger.error(`Error formatting markdown to Google Docs in googleDocsFormatter: ${error.message}`, { stack: error.stack });
    throw error;
  }
}

/**
 * Convert markdown directly to Google Docs API requests using manual parsing.
 *
 * WARNING: This manual parsing is basic and has limitations. It does not use
 * the HTML generated by Showdown above for creating the structured requests.
 *
 * @param {string} markdown - Markdown content
 * @returns {Object} Object containing requests array and current index
 */
function convertToDocRequests(markdown) {
  const requests = [];
  let index = 1; // Start at 1 since the document already has a title
  
  const lines = markdown.split('\n');
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    if (line.trim() === '') {
      requests.push({
        insertText: {
          text: '\n',
          location: { index }
        }
      });
      index += 1;
      continue;
    }
    
    const headingMatch = line.match(/^(#{1,6})\s+(.+)$/);
    if (headingMatch) {
      const level = headingMatch[1].length;
      const text = headingMatch[2];
      
      requests.push({
        insertText: {
          text: text + '\n',
          location: { index }
        }
      });
      
      requests.push({
        updateParagraphStyle: {
          paragraphStyle: {
            namedStyleType: `HEADING_${level}`
          },
          range: {
            startIndex: index,
            endIndex: index + text.length
          },
          fields: 'namedStyleType'
        }
      });
      
      index += text.length + 1;
      continue;
    }
    
    const bulletedListMatch = line.match(/^(\s*)[-*+]\s+(.+)$/); // Support -, *, +
    const numberedListMatch = line.match(/^(\s*)\d+\.\s+(.+)$/);
    
    if (bulletedListMatch) {
      const indentText = bulletedListMatch[1];
      const text = bulletedListMatch[2];
      
      requests.push({
        insertText: {
          text: text + '\n',
          location: { index }
        }
      });
      
      requests.push({
        createParagraphBullets: {
          range: {
            startIndex: index,
            endIndex: index + text.length
          },
          bulletPreset: 'BULLET_DISC_CIRCLE_SQUARE'
        }
      });
      
      // Basic indentation handling (can be improved for proper nesting levels)
      if (indentText.length > 0) {
        requests.push({
          updateParagraphStyle: {
            paragraphStyle: {
              indentStart: {
                magnitude: (indentText.length / 2) * 18, // Assuming 2 spaces per indent level
                unit: 'PT'
              }
            },
            range: {
              startIndex: index,
              endIndex: index + text.length
            },
            fields: 'indentStart'
          }
        });
      }
      
      index += text.length + 1;
      continue;
    }
    
    if (numberedListMatch) {
      const indentText = numberedListMatch[1];
      const text = numberedListMatch[2];
      
      requests.push({
        insertText: {
          text: text + '\n',
          location: { index }
        }
      });
      
      requests.push({
        createParagraphBullets: {
          range: {
            startIndex: index,
            endIndex: index + text.length
          },
          bulletPreset: 'NUMBERED_DECIMAL_NESTED' // Basic numbering
        }
      });
      
      if (indentText.length > 0) {
         requests.push({
          updateParagraphStyle: {
            paragraphStyle: {
              indentStart: {
                magnitude: (indentText.length / 2) * 18, // Assuming 2 spaces per indent level
                unit: 'PT'
              }
            },
            range: {
              startIndex: index,
              endIndex: index + text.length
            },
            fields: 'indentStart'
          }
        });
      }
      
      index += text.length + 1;
      continue;
    }
    
    if (line.trim().startsWith('```')) {
      const codeStartMatch = line.trim().match(/^```([a-zA-Z0-9]*)?$/);
      if (codeStartMatch) {
        let codeContent = '';
        let j = i + 1;
        while (j < lines.length && !lines[j].trim().startsWith('```')) {
          codeContent += lines[j] + '\n';
          j++;
        }
        
        // Remove trailing newline if present from the loop
        if (codeContent.endsWith('\n')) {
            codeContent = codeContent.slice(0, -1);
        }

        if (codeContent.length > 0) {
            requests.push({
              insertText: {
                text: codeContent,
                location: { index }
              }
            });
            
            requests.push({
              updateTextStyle: {
                textStyle: {
                  fontFamily: 'Courier New',
                  backgroundColor: {
                    color: {
                      rgbColor: {
                        red: 0.95,
                        green: 0.95,
                        blue: 0.95
                      }
                    }
                  }
                },
                range: {
                  startIndex: index,
                  endIndex: index + codeContent.length
                },
                fields: 'fontFamily,backgroundColor'
              }
            });
            index += codeContent.length;
        }
         // Add a newline after the code block if it's not the last element or followed by an empty line
        if (j < lines.length -1 || (j === lines.length -1 && lines[j].trim() !== "```") ) {
             requests.push({
                insertText: {
                    text: '\n',
                    location: { index }
                }
            });
            index +=1;
        }
        i = j; 
        continue;
      }
    }
    
    // Regular paragraph: insert text first
    requests.push({
      insertText: {
        text: line + '\n',
        location: { index }
      }
    });
    const lineStartIndex = index;
    index += line.length + 1;

    // Inline formatting (flawed: applies to markdown syntax too)
    // Process bold (**text** or __text__)
    let match;
    const boldRegex = /(\*\*|__)(.*?)\1/g;
    while ((match = boldRegex.exec(line)) !== null) {
      requests.push({
        updateTextStyle: {
          textStyle: { bold: true },
          range: { startIndex: lineStartIndex + match.index, endIndex: lineStartIndex + match.index + match[0].length },
          fields: 'bold'
        }
      });
    }

    // Process italic (*text* or _text_)
    const italicRegex = /(?<!\*|_)(\*|_)((?!\1).*?)\1(?!\1)/g;
    while ((match = italicRegex.exec(line)) !== null) {
      requests.push({
        updateTextStyle: {
          textStyle: { italic: true },
          range: { startIndex: lineStartIndex + match.index, endIndex: lineStartIndex + match.index + match[0].length },
          fields: 'italic'
        }
      });
    }
    
    // Process inline code (`text`)
    const inlineCodeRegex = /`([^`]+?)`/g;
    while ((match = inlineCodeRegex.exec(line)) !== null) {
      requests.push({
        updateTextStyle: {
          textStyle: { fontFamily: 'Courier New' }, // Basic styling for inline code
          range: { startIndex: lineStartIndex + match.index, endIndex: lineStartIndex + match.index + match[0].length },
          fields: 'fontFamily'
        }
      });
    }

    // Process links [text](url)
    const linkRegex = /\[(.*?)\]\((.*?)\)/g;
    while ((match = linkRegex.exec(line)) !== null) {
        // This simplistic version makes the whole "[text](url)" a link.
        // A better version would replace "[text](url)" with "text" and link "text".
      requests.push({
        updateTextStyle: {
          textStyle: { link: { url: match[2] } },
          range: { startIndex: lineStartIndex + match.index, endIndex: lineStartIndex + match.index + match[0].length },
          fields: 'link'
        }
      });
    }
  }
  
  return { requests, index };
}

module.exports = {
  formatMarkdownToGoogleDocsRequests
};